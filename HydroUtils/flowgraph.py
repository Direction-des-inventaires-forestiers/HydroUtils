# -*- coding: utf-8 -*-

"""
/***************************************************************************
 HydroUtils
                                 A QGIS plugin
 Identifie le bassin versant de polygones d'intérêt
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-07-14
        copyright            : (C) 2022 by Jean-François Bourdon (MFFP-DIF)
        email                : jean-francois.bourdon@mffp.gouv.qc.ca
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

  Liste d'améliorations potentielles
    
 -  Évaluer le remplacement de networkx by igraph qui est sensé être plus performant

"""

__author__ = 'Jean-François Bourdon (MFFP-DIF)'
__date__ = '2022-07-14'
__copyright__ = '(C) 2022 by Jean-François Bourdon (MFFP-DIF)'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import *
from PyQt5.QtCore import *
import processing
from processing.core.Processing import Processing
from qgis.analysis import QgsNativeAlgorithms

import glob
import networkx as nx
import os
import pickle
import subprocess

from .sidescripts import *


class flowgraph(QgsProcessingAlgorithm):

    script_dir = os.path.dirname(__file__)
    dict_config = get_config(script_dir)

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterFile(
                'INPUT_indir',
                'Répertoire contenant les écoulements linéaires',
                QgsProcessingParameterFile.Folder
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        indir = self.parameterAsString(parameters, 'INPUT_indir', context)


        # Chargment de la couche d'hydrographie linéaire
        path_hydro = glob.glob(os.path.join(indir, "Hydro_LiDAR_????.gpkg"))
        if len(path_hydro) == 0:
            feedback.reportError(f"Le fichier contenant les écoulements (Hydro_LiDAR_00XX.gpkg) ne semble pas disponible.")
            return {}
        
        udh = path_hydro[0][-9:-5]
        vlayer_streams = QgsVectorLayer(f"{path_hydro[0]}|layername=Hydro_{udh}_l")
        if vlayer_streams.hasFeatures() == 0:
            feedback.reportError(f"La couche d'hydrographie linéaire (Hydro_{udh}_l) ne semble pas être présente ou ne contient aucune entitée.")
            return {}


        # Store the old and new unique FIDs in new fields
        # The null reprojection is only to create a temporary layer and
        # to make sure that the FIDs start at 1 in order to match with
        # FIDs from starting and ending vertices
        fids_ori = [f.id() for f in vlayer_streams.getFeatures(QgsFeatureRequest().setFlags(QgsFeatureRequest().NoGeometry))]

        vlayer_streams = processing.run("native:reprojectlayer", {
            'INPUT':vlayer_streams,
            'TARGET_CRS':vlayer_streams.crs(),
            'OUTPUT':'TEMPORARY_OUTPUT'
            })["OUTPUT"]
        
        with edit(vlayer_streams):
            field_fid_new = "FID_new"
            field_fid_ori = "FID_ori"
            vlayer_streams.addAttribute(QgsField(field_fid_new, QVariant.Int))
            vlayer_streams.addAttribute(QgsField(field_fid_ori, QVariant.Int))
            idx_fid_new = vlayer_streams.fields().indexFromName(field_fid_new)
            idx_fid_ori = vlayer_streams.fields().indexFromName(field_fid_ori)

            for feature, fid_ori in zip(vlayer_streams.getFeatures(), fids_ori):
                vlayer_streams.changeAttributeValues(feature.id(), {idx_fid_new:feature.id(), idx_fid_ori:fid_ori})


        # Extraction séparée des premiers et derniers sommets de chaque segment
        vertices_start = processing.run("native:extractspecificvertices", {
            'INPUT':vlayer_streams,
            'VERTICES':'0',
            'OUTPUT':'TEMPORARY_OUTPUT'
            })["OUTPUT"]

        vertices_end = processing.run("native:extractspecificvertices", {
            'INPUT':vlayer_streams,
            'VERTICES':'-1',
            'OUTPUT':'TEMPORARY_OUTPUT'
            })["OUTPUT"]


        # Prepare core objects for the work to come
        # Dictionaries, set and indexes are used for maximum performance!
        request = QgsFeatureRequest().setSubsetOfAttributes([field_fid_new, field_fid_ori], vertices_start.fields())
        dict_starts = {feature[field_fid_new]:(feature.geometry().constGet(), feature[field_fid_ori]) for feature in vertices_start.getFeatures(request)}
        dict_ends = {feature[field_fid_new]:(feature.geometry().constGet(), feature[field_fid_ori]) for feature in vertices_end.getFeatures(request)}

        index_start = QgsSpatialIndex(vertices_start)

        remaining_fids = set(dict_starts.keys())
        nb_fids = len(remaining_fids)

        G = nx.DiGraph()


        # Check if no pair of endpoints are closer than the tolerance value
        tolerance = 0.001 ** 2
        tolerance_failed = False
        for key, pt_start in dict_starts.items():
            pt_end = dict_ends[key][0]
            dist = pt_start[0].distanceSquared(pt_end.x(), pt_end.y())
            
            if dist <= tolerance:
                tolerance_failed = True
                feedback.reportError(f"Stream located around x:{round(pt_start[0].x(), 1)} y:{round(pt_start[0].y(), 1)} has its ends closer than the tolerance value ({tolerance}).")
        
        if tolerance_failed:
            return {}


        # Loop executed as long as some FIDs haven't been met
        ii = 0
        while remaining_fids:
            # Start the search with a random available FID
            upstream_fid = remaining_fids.pop()
            ii += 1

            # Find immediate downstreams FIDs
            end_coord = dict_ends[upstream_fid][0]
            end_coord_x = end_coord.x()
            end_coord_y = end_coord.y()

            rectangle = QgsRectangle(
                end_coord_x - tolerance,
                end_coord_y - tolerance,
                end_coord_x + tolerance,
                end_coord_y + tolerance
                )
            
            downstream_fids = index_start.intersects(rectangle)

            if len(downstream_fids) > 0:
                # Add edges to DiGraph according to the downstream nodes found
                fid_ori_upstream = dict_ends[upstream_fid][1]
                edges = [(fid_ori_upstream, dict_ends[fid_new][1]) for fid_new in downstream_fids]
                G.add_edges_from(edges)
            
            feedback.setProgress(ii / nb_fids * 100)

        path_GML = os.path.join(indir, f"Hydro_{udh}_l.gml")
        nx.write_gml(G, path_GML)

        # Création d'un fichier pickle car plus rapide à lire que le GML
        path_GML_pickle = path_GML[:-3] + "pickle"
        try:
            with open(path_GML_pickle, 'wb') as gml_file:
                pickle.dump(G, gml_file)
        except:
            pass
            

        feedback.pushInfo(f"Le graphe est disponible au {path_GML}\n")

        return {}


    def name(self):
        return 'flowgraph'

    def displayName(self):
        return 'Construction du graphe des écoulements linéaires'

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return flowgraph()
