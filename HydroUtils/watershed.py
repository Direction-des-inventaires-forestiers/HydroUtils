# -*- coding: utf-8 -*-

"""
/***************************************************************************
 HydroUtils
                                 A QGIS plugin
 Identifie le bassin versant de polygones d'intérêt
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-07-14
        copyright            : (C) 2022 by Jean-François Bourdon (MFFP-DIF)
        email                : jean-francois.bourdon@mffp.gouv.qc.ca
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

 - Il y a un bug présentement dans l'outil Watershed de WBT qui fait en sorte que le raster de pour points doit avoir une valeur de nodata inférieure
   ou égale à zéro sinon le résultat n'est pas bon. C'est probablement à la ligne 381 de watershed.rs que le problème se trouve. À noter que si la
   valuer de NoData spécifiée dans l'en-tête ne se trouve pas en réalité dans le raster, ça ne cause pas problème. En fait, j'ai l'impression
   que la nodata ne sert juste à rien dans cet outil. Toute valeur égale ou inférieure à 0 est considérée NoData, point à la ligne.

 - Il y a aussi un limitation dans WBT qui fait en sorte que les chemins d'accès ne peuvent pas contenir d'espace (pour un raster en sortie du moins).
   Ce serait à rapporter et à corriger. Pour contourner le problème, je retire les espaces dans le nom de l'entité utilisée pour
   construire le nom du répertoire temporaire.
"""

__author__ = 'Jean-François Bourdon (MFFP-DIF)'
__date__ = '2022-07-14'
__copyright__ = '(C) 2022 by Jean-François Bourdon (MFFP-DIF)'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import *
from PyQt5.QtCore import *
import processing
from processing.core.Processing import Processing
from qgis.analysis import QgsNativeAlgorithms

import datetime
import glob
import itertools
import networkx as nx
from operator import itemgetter
import os
import shutil
import subprocess

from .sidescripts import *


class watershed(QgsProcessingAlgorithm):

    script_dir = os.path.dirname(__file__)
    dict_config = get_config(script_dir)
    success = True

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterFile(
                'INPUT_tempdir',
                'Répertoire temporaire',
                QgsProcessingParameterFile.Folder,
                defaultValue=self.dict_config["variables"]["tempdir"]
            )
        )

        self.addParameter(
            QgsProcessingParameterFile(
                'INPUT_d8',
                'Répertoire contenant les écoulements et les D8',
                QgsProcessingParameterFile.Folder
            )
        )

        self.addParameter(
            QgsProcessingParameterVectorLayer(
                'INPUT_occurrences',
                'Occurrences (lignes ou polygones)',
                [QgsProcessing.TypeVectorLine, QgsProcessing.TypeVectorPolygon]
            )
        )
        
        self.addParameter(
            QgsProcessingParameterBoolean(
                'INPUT_only_selected',
                'Utiliser uniquement les entitées sélectionnées',
                defaultValue=False
            )
        )
    
        self.addParameter(
            QgsProcessingParameterField(
                'INPUT_field_occurrences',
                'Identifiant unique des occurrences',
                defaultValue=None,
                parentLayerParameterName="INPUT_occurrences"
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSink(
                'OUTPUT_watershed',
                'Bassins versants des occurrences'
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        roottempdir = os.path.normpath(self.parameterAsString(parameters, 'INPUT_tempdir', context))
        dird8 = os.path.normpath(self.parameterAsString(parameters, 'INPUT_d8', context))
        vlayer_occurrences_ori = self.parameterAsVectorLayer(parameters, 'INPUT_occurrences', context)
        bool_only_selected = self.parameterAsBool(parameters, 'INPUT_only_selected', context)
        field_occurrences = self.parameterAsFields(parameters, 'INPUT_field_occurrences', context)[0]


        # Chargement de l'index d'UD et des écoulements linéaires
        path_index = glob.glob(os.path.join(dird8, f"Hydro_LiDAR_????.gpkg"))
        if len(path_index) == 0:
            self.success = False
            feedback.reportError(f"Le fichier contenant les écoulements (Hydro_LiDAR_00XX.gpkg) ne semble pas être présent au {dird8}.\n")
            return {}
        elif len(path_index) > 1:
            self.success = False
            feedback.reportError("Plusieurs fichiers contenant des écoulements (Hydro_LiDAR_00XX.gpkg) ont été trouvés. Veuillez séparer chaque UDH dans son propre répertoire.\n")
            return {}

        udh = path_index[0][-9:-5]
        vlayer_streams = QgsVectorLayer(f"{path_index[0]}|layername=RH_L")
        if vlayer_streams.hasFeatures() == 0:
            self.success = False
            feedback.reportError(f"La couche d'hydrographie linéaire (RH_L) ne semble pas être présente ou ne contient aucune entitée.\n")
            return {}
        
        vlayer_indexUD = QgsVectorLayer(f"{path_index[0]}|layername=S_UDH")
        if vlayer_indexUD.hasFeatures() == 0:
            self.success = False
            feedback.reportError(f"La couche d'index des sous-unités de découpage hydrique (S_UDH) ne semble pas être présente ou ne contient aucune entitée.\n")
            return {}


        # Création du QgsVectorLayer de sortie contenant les bassins versants de chaque occurrence
        fields_array = [
            vlayer_occurrences_ori.fields().field(field_occurrences),
            QgsField('UDH', QVariant.String, len=4),
            QgsField('Superficie_ha', QVariant.Double, len=15, prec=2)
            ]
        
        fields_watershed = QgsFields()
        for field in fields_array:
            fields_watershed.append(field)

        sinkCrs = QgsCoordinateReferenceSystem("EPSG:6622")
        (sink, self.sink_id) = self.parameterAsSink(parameters, 'OUTPUT_watershed', context, fields_watershed, QgsWkbTypes.MultiPolygon, sinkCrs)


        # Sauvegarde du répertoire par défaut
        self.dict_config["variables"]["tempdir"] = roottempdir
        write_config(self.dict_config, self.script_dir)


        # Chemin d'accès à Whitebox Tools
        path_wbt = os.path.join(self.script_dir, "whitebox_tools.exe")


        # Paramètres pour les appels à subprocess.run()
        startupinfo = subprocess.STARTUPINFO()
        startupinfo.dwFlags = subprocess.STARTF_USESHOWWINDOW
        startupinfo.wShowWindow = int(self.dict_config["variables"]["wShowWindow"])


        # Valider que les valeurs de "field_occurrences" sont bien uniques
        request = QgsFeatureRequest().setFlags(QgsFeatureRequest().NoGeometry)
        ls_ID = [feature.attribute(field_occurrences) for feature in vlayer_occurrences_ori.getFeatures(request)]
        if len(ls_ID) != len(set(ls_ID)):
            feedback.reportError(f"Le champ {field_occurrences} contient des doublons.")
            return {}


        # Sélection des occurrences à utiliser
        vlayer_occurrences = vlayer_occurrences_ori.clone()
        if not bool_only_selected:
            vlayer_occurrences.selectAll()


        # Validation que les occurrences touchent bel et bien aux UD fournies
        context.project().addMapLayer(vlayer_occurrences, False)
        vlayer_occurrences_touched = processing.run("native:extractbylocation", {
            'INPUT':QgsProcessingFeatureSourceDefinition(vlayer_occurrences.id(), True),
            'PREDICATE':[0],
            'INTERSECT':vlayer_indexUD,
            'OUTPUT':'TEMPORARY_OUTPUT'
            })["OUTPUT"]
        context.project().removeMapLayer(vlayer_occurrences.id())
        
        if vlayer_occurrences_touched.hasFeatures() == 0:
            self.success = False
            feedback.reportError("Aucune occurrence ne touche à l'UDH.\n")
            return {}

        ID_ori = set([str(feature.attribute(field_occurrences)) for feature in vlayer_occurrences.getSelectedFeatures(request)])
        ID_touched = set([str(feature.attribute(field_occurrences)) for feature in vlayer_occurrences_touched.getFeatures(request)])
        ID_diff = list(ID_ori.difference(ID_touched))
        if len(ID_diff):
            if len(ID_diff) > 1:
                accord = "Les occurrences sélectionnées suivantes ne seront pas traitées car elles ne touchent"
            else:
                accord = "L'occurrence sélectionnée suivante ne sera pas traitée car elle ne touche"
            
            feedback.pushInfo(f"--> Attention! {accord} pas à l'UDH: {', '.join(ID_diff)}\n")


        # Avertissement si les occurrences sont multipart
        # Chaque entité est vérifiée pour palier au fait que les SHP provenant d'ESRI sont toujours lus
        # comme étant multipart même si toutes les géométries sont individuellement simplepart
        containsMultipart = False
        for feature in vlayer_occurrences_touched.getFeatures():
            nb_parts = len(list(feature.geometry().constParts()))
            if nb_parts > 1:
                containsMultipart = True

        if containsMultipart:
            feedback.pushInfo(" --> Attention! Vous pourriez obtenir des bassins versants disjoints puisque la couche d'occurrences contient certaines géométries multiparties.\n")


        # Construction du graph des écoulements pour déterminer plus tard si des S_UDH
        # plus en amont doivent être ajoutés au bassin versant délimité
        G = getStreamsGraph(vlayer_streams)


        # Bouclage pour traiter toutes occurrences consécutivement
        ls_fids = [(feature.id(), feature.attribute(field_occurrences)) for feature in vlayer_occurrences_touched.getFeatures(request)]
        ls_fids.sort(key=itemgetter(1))
        nb_occurrences = len(ls_fids)
        feedback.setProgress(1)

        for ii, (fid, ID) in enumerate(ls_fids):

            if feedback.isCanceled():
                return {}

            feedback.pushInfo(f"{ii+1}/{nb_occurrences} - Occurrence \"{ID}\"")

            # Création du répertoire temporaire
            now = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            tempdir = os.path.join(roottempdir, f"HydroUtils_occurrence_{ID}_{now}")
            os.makedirs(tempdir)
            print("Répertoire temporaire => " + tempdir)


            # Détermine quelles sont les UD touchées par l'occurrence
            vlayer_occurrences_touched.selectByIds([fid])
            vlayer_occurrence_selected = processing.run("native:saveselectedfeatures", {
                'INPUT':vlayer_occurrences_touched,
                'OUTPUT':'TEMPORARY_OUTPUT'
                })["OUTPUT"]
            
            vlayer_indexUD_touched = processing.run("native:extractbylocation", {
                'INPUT':vlayer_indexUD,
                'PREDICATE':[0],
                'INTERSECT':vlayer_occurrence_selected,
                'OUTPUT':'TEMPORARY_OUTPUT'
                })["OUTPUT"]


            # Bouclage pour extraire le bassin versant pour chaque UD touchée par l'occurrence
            ls_ud = [feature["S_UDH"] for feature in vlayer_indexUD_touched.getFeatures(request)]
            ls_path_watershed = []
            for ud in ls_ud:
                ud_str = str(ud).zfill(3)
                feedback.pushInfo(f"Calcul du bassin versant dans la sous-unité de découpage hydrique {ud_str}")

                # Rasterisation de l'occurrence dans la projection de l'UD
                path_d8 = glob.glob(os.path.join(dird8, f"D8_directions_????_{ud_str}_*.sdat"))
                if len(path_d8) == 0:
                    self.success = False
                    feedback.reportError(f"La matrice de directions de flux pour la sous-unité de découpage hydrique {ud_str} ne semble pas disponible.\n")
                    return {}
                
                path_d8 = path_d8[0]
                udh = os.path.basename(path_d8)[14:18]
                dict_d8 = load_raster(path_d8, readArray=False)
                d8Crs = QgsCoordinateReferenceSystem("EPSG:6622")

                path_occurrence_mask = os.path.join(tempdir, f"mask_occurrence_{ud_str}.sdat")
                rasterize_AOI(vlayer_occurrence_selected, d8Crs.authid(), dict_d8["georef"], dict_d8["xsize"], dict_d8["ysize"], path_occurrence_mask)


                # Extraction du bassin versant via le masque
                path_watershed_SDAT = os.path.join(tempdir, f"watershed_{ud_str}.sdat")
                run_wbt("Watershed", {
                    "d8_pntr":path_d8,
                    "pour_pts":path_occurrence_mask,
                    "output":path_watershed_SDAT
                    }, path_wbt, startupinfo)
                

                # Conversion de l'aire de drainage matricielle en polygone
                path_watershed_temp_SHP = os.path.join(tempdir, f"watershed_polygonize_{ud_str}.shp")
                processing.run("gdal:polygonize", {
                    'INPUT':path_watershed_SDAT,
                    'BAND':1,
                    'FIELD':'DN',
                    'EIGHT_CONNECTEDNESS':False,
                    'OUTPUT':path_watershed_temp_SHP
                    })
                

                # Réparation des géométries, ajout de la projection et 
                # transformation en multi-parties pour couvrir les cas d'un pixel (ou groupe de pixels)
                # ne touchant au polygon principal que par une diagonale.
                # Normalement, le paramètre 'EIGHT_CONNECTEDNESS':True de gdal:polygonize
                # devrait justement s'en charger, mais j'ai eu un cas où ça n'a pas fonctionné comme prévu.
                path_watershed_SHP = os.path.join(tempdir, f"watershed_fixed_{ud_str}.shp")
                vlayer_watersehd_fixed = processing.run("native:fixgeometries", {'INPUT':path_watershed_temp_SHP, 'OUTPUT':'TEMPORARY_OUTPUT'})["OUTPUT"]
                processing.run("native:collect", {'INPUT':vlayer_watersehd_fixed,'FIELD':['DN'],'OUTPUT':path_watershed_SHP})
                processing.run("qgis:definecurrentprojection", {'INPUT':path_watershed_SHP, 'CRS':d8Crs})

                ls_path_watershed.append(path_watershed_SHP)
            

            # Fusion des bassins versants initiaux
            vlayer_watershed = processing.run("native:mergevectorlayers", {
                'LAYERS':ls_path_watershed,
                'OUTPUT':'TEMPORARY_OUTPUT'
                })["OUTPUT"]



            ## Ajout des UD en amont si le bassin versant initial touche à des exutoires en amont
            # Les occurences sont analysées individuellement afin de gérer adéquatement le cas des multiparties.
            # En effet, si des parties sont dans des S_UDH différentes et que l'une des ces S_UDH se trouve en amont
            # d'une autre, le script excluerait la S_UDH située en amont du bassin versant final.
            # ATTENTION ! Il est assumé que les occurences en entrées intersectent des écoulements. Si ce n'est pas le cas,
            #             et que le bassin versant englobe un S_UDH en amont, cette dernière sera manquée car la recherche
            #             se base sur l'analyse réseau des écoulements vectoriels.
            occurrence_single = processing.run("native:multiparttosingleparts", {
                'INPUT':vlayer_occurrence_selected,
                'OUTPUT':'TEMPORARY_OUTPUT'
                })["OUTPUT"]

            ls_upstream_watersheds = []
            for feature in occurrence_single.getFeatures():

                # Création de la liste des S_UDH immédiatement en amont
                # Originalement, j'utilisais "vlayer_watershed" pour faire une intersection sur les S_UDH, mais s'il
                # y a une divergence trop grande entre les modélisations et qu'un ruisseau permanent passe très près
                # d'une S_UDH voisine, elle pourra être erronément sélectionnée. Il est donc plus sûr de passer par
                # une analyse réseau basée sur les vecteurs même si ce n'est pas à toute épreuve non plus.
                # La démarche aurait intérêt à être revue lorsque les matrices s'imbriqueront parfaitement même si
                # cette façon de faire demeurera valide.
                context.project().addMapLayer(vlayer_streams, False)
                context.project().addMapLayer(occurrence_single, False)
                occurrence_single.selectByIds([feature.id()])
                processing.run("native:selectbylocation", {
                    'INPUT':vlayer_streams,
                    'PREDICATE':[0],
                    'INTERSECT':QgsProcessingFeatureSourceDefinition(occurrence_single.id(), True),
                    'METHOD':0
                    })
                
                # Identification des derniers segments en amont
                ls_starting_node = [str(feature.id()) for feature in vlayer_streams.getSelectedFeatures()]
                all_upstream_nodes = [
                    [int(node_from) for node_from, *_ in nx.edge_dfs(G, starting_node, orientation="reverse") if len(list(G.predecessors(node_from))) == 0]
                    for starting_node
                    in ls_starting_node
                ]

                vlayer_streams.selectByIds(list(itertools.chain.from_iterable(all_upstream_nodes)))
                processing.run("native:selectbylocation", {
                    'INPUT':vlayer_indexUD,
                    'PREDICATE':[1],  # Segments complètement contenus seulement
                    'INTERSECT':QgsProcessingFeatureSourceDefinition(vlayer_streams.id(), True),
                    'METHOD':0
                    })
                context.project().removeMapLayer(vlayer_streams.id())
                context.project().removeMapLayer(occurrence_single.id())

                # Identification des S_UDH en amont
                set_ud_intersect = set([feature["S_UDH"] for feature in vlayer_indexUD.getSelectedFeatures()])
                set_ud_ori = set(ls_ud)
                set_ud_upstream = set_ud_intersect.difference(set_ud_ori)

                if len(set_ud_upstream):
                    # Extraction et fusion des S_UDH pertinentes
                    upstream_watersheds = processing.run("native:extractbyexpression", {
                        'INPUT':vlayer_indexUD,
                        'EXPRESSION':f'"S_UDH" IN ({",".join([str(x) for x in set_ud_upstream])})',
                        'OUTPUT':'TEMPORARY_OUTPUT'
                        })["OUTPUT"]

                    ls_upstream_watersheds.append(upstream_watersheds)


            if len(ls_upstream_watersheds):
                vlayer_watershed = processing.run("native:mergevectorlayers", {
                    'LAYERS':ls_upstream_watersheds + [vlayer_watershed],
                    'OUTPUT':'TEMPORARY_OUTPUT'
                    })["OUTPUT"]

                vlayer_watershed = processing.run("native:dissolve", {
                    'INPUT':vlayer_watershed,
                    'FIELD':[],
                    'OUTPUT':'TEMPORARY_OUTPUT'
                    })["OUTPUT"]
                
                # Retrait des trous entre UD... éventuellement il faudrait plutôt que je règle ce problème à la
                # source en ayant des matrices de direction de flux qui s'imbriquent parfaitement. Il faut donc
                # régler le problème d'incertitude avec les modélisations adjacentes.
                vlayer_watershed = processing.run("native:deleteholes", {
                    'INPUT':vlayer_watershed,
                    'MIN_AREA':2000,
                    'OUTPUT':'TEMPORARY_OUTPUT'
                    })["OUTPUT"]


            # Ajout de la géométrie au sink en faisant suivre le numéro de l'occurrence ainsi que le numéro d'UDH
            geom = vlayer_watershed.getFeature(1).geometry()
            geom.transform( QgsCoordinateTransform(vlayer_watershed.crs(), sinkCrs, QgsProject.instance()) )

            geom_6624 = QgsGeometry(geom)
            geom_6624.transform( QgsCoordinateTransform(sinkCrs, QgsCoordinateReferenceSystem("EPSG:6624"), QgsProject.instance()) )

            fet = QgsFeature()
            fet.setGeometry(geom)
            fet.setAttributes([ID, udh, geom_6624.area() / 10000])  # superficie en Albers
            sink.addFeature(fet)
            feedback.setProgress((ii+1) / nb_occurrences * 100)
            feedback.pushInfo("")


            # Suppression des fichiers temporaires
            shutil.rmtree(tempdir)

        return {}

 
    def postProcessAlgorithm(self, context, feedback):
        if self.success:
            output = QgsProcessingUtils.mapLayerFromString(self.sink_id, context)
            output.loadNamedStyle(os.path.join(self.script_dir, "bv.qml"), True)
            output.triggerRepaint()

            if self.sink_id[-5:].lower() == ".gpkg":
                output.saveStyleToDatabase(name="Bassins", description="", useAsDefault=True, uiFileContent="")

        return {}

    def name(self):
        return 'watershed'

    def displayName(self):
        return 'Déterminer les bassins versants d\'occurrences'

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return watershed()
